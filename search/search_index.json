{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FalCAuN","text":"<p>FalCAuN is a toolkit for testing black-box systems (e.g., cyber-physical systems) based on automata learning and model checking. Currently, systems implemented in Java, Simulink, and Python are supported.</p> <p>FalCAuN is implemented in Java and can be used from any JVM language (for example Kotlin or Clojure). The source code is partially commented on using the Javadoc syntax. The document is hosted on GitHub Pages. FalCAuN uses LearnLib, an open source framework for automata learning. It is available under the GNU General Public License Version 3.0.</p>"},{"location":"#contributors","title":"Contributors","text":"<p>The development of FalCAuN has been led by Masaki Waga. The following people contributed to FalCAuN.</p> <ul> <li>Masaki Waga: 2019--</li> <li>Junya Shijubo: 2021--2022</li> <li>Hiromasa Saito: 2024--</li> </ul>"},{"location":"#references","title":"References","text":"<ul> <li>[Shijubo+, RV'21] Efficient Black-Box Checking via Model Checking with Strengthened Specifications. Junya Shijubo, Masaki Waga, and Kohei Suenaga</li> <li>[Waga, HSCC'20] Falsification of cyber-physical systems with robustness-guided black-box checking. Masaki Waga</li> </ul>"},{"location":"cli/","title":"Obsolete CLI interface","text":"<p>After FalCAuN 1.0, FalCAuN is mainly intended to be used as a library called from a program written in some JVM language, such as Kotlin. The CLI interface is still available for backward compatibility, but it is not actively maintained.</p> <p>To execute FalCAuN via the CLI interface, you can use the helper shell script <code>falcaun</code> in the root directory of the repository. The script is a wrapper of the CLI interface of FalCAuN. The script is written in POSIX sh and should work on most UNIX-like operating systems. An example of usage is as follows. This takes at least a few minutes for MATLAB to start up and another few minutes to falsify all the STL formulas in <code>./example/AT_M4.stl</code>. Please be patient!!</p> <pre><code>./falcaun --stl-file=./example/AT_M4.stl --output-mapper=./example/AT_M4.omap.tsv --input-mapper=./example/AT.imap.tsv --equiv=GA --step-time=1.0 --signal-length=30  --init='cd ./example; initAT' --max-test=50000 --param-names=\"throttle brake\" --ga-crossover-prob=0.5 --ga-mutation-prob=0.01 --population-size=150 --ga-selection-kind=Tournament\n</code></pre> <p>You can also install this script as follows.</p> <pre><code>sudo install falcaun /usr/local/bin\n</code></pre>"},{"location":"cli/#usage-of-the-cli-interface","title":"Usage of the CLI interface","text":""},{"location":"cli/#synopsis","title":"Synopsis","text":"<pre><code> ./falcaun [OPTIONS] --stl=[STLFormula] --input-mapper=[InputMapperFile] --output-mapper=[OutputMapperFile] --equiv=[HC|random|WP|SA|GA]\n</code></pre>"},{"location":"cli/#general-options","title":"General Options","text":"<p>-h, --help Print a help message.  -v, --verbose It outputs extra information, mainly for debugging.  -V, --version Print the version  -t timeout, --timeout timeout Set timeout [seconds] -f file, --stl-file file Read an STL formula from file.  -e STLFormula, --stl STLFormula Specify STLFormula by signal temporal logic.  -I file, --input-mapper file Read the input mapper configuration from file.  -O file, --output-mapper file Read the output mapper configuration from file.  -S file, --signal-mapper file Read the signal mapper from file.  -E algorithm, --equiv algorithm Specify the equivalence testing algorithm. See below for the detail.  -o file, --output-dot file Write the learned Mealy machine to file in DOT format.  --output-etf file Write the learned Mealy machine to file in ETF format.  -s step-time, --step-time step-time Specify the step time of the sampling.  -l length, --signal-length length Specify the length of the sampled signals.  -i script, --init script The initial script of MATLAB  -p param1 param2 ... paramN, --param-names param1 param2 ... paramN The parameter names of the Simulink model  -M test-size, --max-test test-size The maximum test size  --disable-adaptive-stl Disable the adaptive STL updater in [Shijubo+, RV'21]</p>"},{"location":"cli/#options-specific-to-the-equivalence-testing","title":"Options Specific to the Equivalence Testing","text":"<p>When you use GA, SA, or WP for the equivalence testing, you have to specify the following options in addition.</p>"},{"location":"cli/#ga-genetic-algorithm","title":"GA (Genetic Algorithm)","text":"<p>--population-size size The size of the population  --ga-crossover-prob prob The crossover probability (should be between 0 and 1)  --ga-mutation-prob prob The mutation probability (should be between 0 and 1)  --ga-selection-kind [bestsolution|tournament] The selection in the genetic algorithm. Either best solution selection or binary tournament.</p>"},{"location":"cli/#sa-simulated-annealing","title":"SA (Simulated Annealing)","text":"<p>--sa-alpha alpha The alpha parameter for simulated annealing (should be between 0 and 1)</p>"},{"location":"cli/#wp-wp-method","title":"WP (Wp-method)","text":"<p>--wp-max-depth depth The maximum depth in the Wp-method</p>"},{"location":"cli/#file-format-of-the-mapper","title":"File format of the mapper","text":"<p>Both input and output mappers are specified by TSV files.</p>"},{"location":"cli/#input-mapper","title":"Input mapper","text":"<p>Input mapper specifies the possible input values of each signal (e.g., break and throttle). Each signal can take a different number of inputs i.e., N0 and N1 can be different.</p> <pre><code>&lt;value 1 of signal(0)&gt;  &lt;value 2 of signal(0)&gt;  ... &lt;value N0 of signal(0)&gt;\n&lt;value 1 of signal(1)&gt;  &lt;value 2 of signal(1)&gt;  ... &lt;value N1 of signal(1)&gt;\n...                     \n</code></pre> <p>For example, the following shows that:</p> <ul> <li>the domain of <code>signal(0)</code> is 10 and 40; and</li> <li>the domain of <code>signal(1)</code> is 0, 50, and 100.</li> </ul> <pre><code>10  40\n0   50  100\n</code></pre>"},{"location":"cli/#output-mapper","title":"Output mapper","text":"<p>Output mapper specifies how we map the real-valued signal to an atomic proposition. Precisely, we split the vector space R^n by grids. Each grid is one atomic proposition. Since the maximum upper bound is the positive infinity, the last cell for each signal must be <code>inf</code>.</p> <p><pre><code>&lt;upper bound of signal(0) for AP0-1&gt;    &lt;upper bound of signal(0) for AP0-2&gt;    ... &lt;upper bound of signal(0) for AP0-N0&gt;\n&lt;upper bound of signal(0) for AP1-1&gt;    &lt;upper bound of signal(1) for AP1-2&gt;    ... &lt;upper bound of signal(1) for AP1-N1&gt;\n...\n</code></pre> For example, the following output mapper stands for as follows.</p> <ul> <li>For <code>signal(0)</code>:</li> <li><code>AP0-1</code> holds if <code>signal(0)</code> &lt;= 10;</li> <li><code>AP0-2</code> holds if 10 &lt; <code>signal(0)</code> &lt;= 40; and</li> <li><code>AP0-3</code> holds if 40 &lt; <code>signal(0)</code>.</li> <li>For <code>signal(1)</code>:</li> <li><code>AP1-1</code> holds if <code>signal(1)</code> &lt;= 0;</li> <li><code>AP1-2</code> holds if 0 &lt; <code>signal(1)</code> &lt;= 50;</li> <li><code>AP1-3</code> holds if 50 &lt; <code>signal(1)</code> &lt;= 100; and</li> <li><code>AP1-4</code> holds if 100 &lt; <code>signal(1)</code>.</li> <li>For <code>signal(2)</code>, <code>AP2-1</code> always holds.</li> </ul> <pre><code>10  40  inf\n0   50  100 inf\ninf\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>The following is a list of examples. To run the <code>Kotlin</code> examples, you need to install kscript. To run the <code>Jupyter</code> example, you need to set up Jupyter with the kotlin-jupyter kernel. Some examples use the Python binding and require JEP.</p>"},{"location":"examples/#examples-not-requiring-matlabsimulink","title":"Examples not requiring MATLAB/Simulink","text":"<p>The following examples do not require MATLAB/Simulink.</p> Name Description Links Mealy A small Mealy machine Kotlin Jupyter Counter A toy system with a counter Jupyter Python SUL A Mealy machine implemented in Python Python"},{"location":"examples/#examples-requiring-matlabsimulink","title":"Examples requiring MATLAB/Simulink","text":"<p>The following examples require MATLAB/Simulink.</p> Name Description Links AT1 The automatic transmission benchmark against the S1 formula in ARCH-COMP Kotlin AT2 The automatic transmission benchmark against the S2 formula in ARCH-COMP Kotlin AT6a The automatic transmission benchmark against the S6a formula in ARCH-COMP Kotlin AT6b The automatic transmission benchmark against the S6b formula in ARCH-COMP Kotlin AT6c The automatic transmission benchmark against the S6c formula in ARCH-COMP Kotlin AT6abc The automatic transmission benchmark against the S6abc formula in ARCH-COMP Kotlin CC1 The chasing cars benchmark against the CC1 formula in ARCH-COMP Kotlin CC2 The chasing cars benchmark against the CC2 formula in ARCH-COMP Kotlin CC3 The chasing cars benchmark against the CC3 formula in ARCH-COMP Kotlin CC4 The chasing cars benchmark against the CC4 formula in ARCH-COMP Kotlin CCx The chasing cars benchmark against the CCx formula in ARCH-COMP Kotlin"},{"location":"faq/","title":"FAQ","text":"<ul> <li>FalCAuN says \"infinite robustness\". What should I do?<ul> <li>It can be because the generated signal is too short for the temporal formula. Please make <code>signalLength</code> given to <code>AdaptiveSTLList</code> as long as the time window of the STL formulas.</li> </ul> </li> </ul>"},{"location":"install/","title":"Installation","text":"<p>FalCAuN is fully implemented in Java. FalCAuN works on many UNIX-like operating systems. We tested FalCAuN on macOS Sequoia 15.5, Ubuntu 24.04, Ubuntu 22.04, and Arch Linux.</p>"},{"location":"install/#requirements","title":"Requirements","text":"<p>The requirements for the core and examples modules of FalCAuN are as follows.</p> <ul> <li>Java 17</li> <li>Maven</li> <li>LTSMin 3.1.0<ul> <li>This is not officially released yet.</li> <li>You can download it from HERE.</li> </ul> </li> </ul> <p>The matlab module also requires the following.</p> <ul> <li>MATLAB/Simulink<ul> <li>We tested with MATLAB R2024a, but any later version should be fine.</li> </ul> </li> </ul>"},{"location":"install/#installation-of-the-core-module","title":"Installation of the core Module","text":"<p>Here, we provide the instructions to install the core module of FalCAuN.</p>"},{"location":"install/#1-install-the-requirements","title":"1. Install the Requirements","text":"<p>You need to install the requirements above. For example, on Ubuntu, you can install Java 17 and Maven by the following command.</p> UbuntumacOS <pre><code>sudo apt-get install maven openjdk-17-jdk-headless -y\n</code></pre> <pre><code>brew install maven openjdk@17\n</code></pre> <p>You have to manually install LTSMin 3.1.0 and MATLAB/Simulink. For example, you can install LTSMin 3.1.0 with the following commands.</p> <pre><code>wget https://github.com/Meijuh/ltsmin/releases/download/v3.1.0/ltsmin-v3.1.0-linux.tgz -O ltsmin-v3.1.0-linux.tgz\ntar xvf ltsmin-v3.1.0-linux.tgz\nsudo cp -r ./v3.1.0/share /usr/local/share\nsudo cp -r ./v3.1.0/include /usr/local/include\nsudo install ./v3.1.0/bin/* /usr/local/bin\n</code></pre> <p>We provide a script to check if some of the requirements are installed. You can run the script by the following command. Since this script also checks the dependencies of the matlab module, you can ignore the error messages related to the matlab module.</p> <pre><code>./utils/check_env.sh\n</code></pre>"},{"location":"install/#2-build-and-install-falcaun","title":"2. Build and Install FalCAuN","text":"<p>You can build and install FalCAuN using Maven. An example of installing the core module and the top-level module is as follows.</p> <pre><code>mvn install --also-make --projects core\n</code></pre> <p>You can also install the examples module as follows.</p> <pre><code>mvn install --also-make --projects core, examples\n</code></pre>"},{"location":"install/#installation-of-the-matlab-module","title":"Installation of the matlab Module","text":"<p>Here, we provide the instructions to install the matlab module.</p> <p>Note</p> <p>For the matlab module, the unit test on <code>mvn install</code> is disabled by default because it can be time-consuming. If you want, you can run it by <code>mvn test -DskipTests=false</code>.</p>"},{"location":"install/#1-install-the-requirements_1","title":"1. Install the Requirements","text":"<p>You need to install MATLAB/Simulink manually. Please follow the instructions on the official website of Mathworks.</p>"},{"location":"install/#2-setup-the-environment-variable","title":"2. Setup the environment variable","text":"<p>We assume that the environment variable <code>MATLAB_HOME</code> shows where MATLAB is installed. An example is as follows.</p> <pre><code>export MATLAB_HOME=&lt;path/to/matlab/home&gt;\n## Example:\n# export MATLAB_HOME=/usr/local/MATLAB/R2024a/\n</code></pre>"},{"location":"install/#3-build-and-install-falcaun","title":"3. Build and Install FalCAuN","text":"<p>You can build and install FalCAuN using Maven. You have to execute <code>mvn clean</code> to set up the Java API of MATLAB. An example to install the matlab module, as well as the others, is as follows.</p> <pre><code>mvn clean --projects matlab\nmvn install\n</code></pre>"},{"location":"install/#installation-of-the-python-binding-module","title":"Installation of the python binding Module","text":"<p>Here, we provide the instructions to install the python binding module.</p>"},{"location":"install/#1-install-the-requirements_2","title":"1. Install the Requirements","text":"<p>You need to install Jep manually. Follow the instructions on the official site</p>"},{"location":"install/#2-setup-the-environment-variable_1","title":"2. Setup the environment variable","text":"<p>Add the installed path, which has the JEP native library including <code>jep-VERSION.jar</code>, to the environment variable <code>LD_LIBRARY_PATH</code>.</p> <pre><code>export LD_LIBRARY_PATH=&lt;path/to/jep&gt;:${LD_LIBRARY_PATH}\n# Example:\n# export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:$PYENV_ROOT/versions/3.10.15/lib/python3.10/site-packages/jep\n</code></pre>"},{"location":"install/#3-build-and-install-falcaun_1","title":"3. Build and Install FalCAuN","text":"<pre><code>mvn install --also-make --projects python\n</code></pre>"},{"location":"install/#installation-of-ltsmin-310-on-macos-with-arm-processors","title":"Installation of LTSMin 3.1.0 on macOS with ARM Processors","text":"<p>FalCAuN works on macOS with ARM Processors, but the setup of LTSMin is a bit tricky because it only supports x86_64. One can still run LTSMin using Rosetta and libtool for x86_64.</p> <ol> <li>Set up Rosetta on the macOS</li> <li>Install Homebrew for intel processors with <code>arch -x86_64 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\"</code></li> <li>Install <code>libtool</code> for x86_64 with <code>/usr/local/bin/brew install libtool</code></li> </ol>"},{"location":"install/#notes","title":"Notes","text":"<ul> <li>You may have to explicitly specify <code>JAVA_HOME</code>, for example, <code>JAVA_HOME=$(/usr/libexec/java_home -v 17) mvn test -DskipTests=False</code>.</li> <li>The automatic transmission model requires parameters defined in an example by Mathworks. To load it, you probably need to set up the example by Mathworks and the path beforehand.<ul> <li>The example by Mathworks can be opened with <code>openExample('simulink_automotive/ModelingAnAutomaticTransmissionControllerExample')</code></li> <li>See <code>./src/test/resources/MATLAB/initAT.m</code> for an example to set the path.</li> </ul> </li> </ul>"},{"location":"stl/","title":"STL","text":"<p>In FalCAuN, signal temporal logic (STL) is used to specify the tested property. The following shows the syntax of STL in FalCAuN.</p> <pre><code>expr : atomic\n     | expr &amp;&amp; expr\n     | expr || expr\n     | expr -&gt; expr\n     | ! expr\n     | GLOBALLY expr\n     | GLOBALLY _ INTERVAL expr\n     | EVENTUALLY expr\n     | EVENTUALLY _ INTERVAL expr\n     | X expr\n     | expr U expr\n     | expr U _ INTERVAL expr\n     | ( expr )\n\natomic : signal(NATURAL) == value\n       | signal(NATURAL) &lt; value\n       | signal(NATURAL) &gt; value\n       | signal(NATURAL) != value\n       | input(NATURAL) == value\n       | input(NATURAL) &lt; value\n       | input(NATURAL) &gt; value\n       | input(NATURAL) != value\n       | output(NATURAL) == value\n       | output(NATURAL) &lt; value\n       | output(NATURAL) &gt; value\n       | output(NATURAL) != value\n\nvalue : -? NATURAL | -? FLOAT\n\nGLOBALLY : '[]' | 'alw' | 'G'\n\nEVENTUALLY : '&lt;&gt;' | 'ev' | 'F'\n\nINTERVAL : [ NATURAL , NATURAL ]\n</code></pre>"},{"location":"tutorial/tutorial/","title":"Tutorial","text":""},{"location":"tutorial/tutorial/#introduction","title":"Introduction","text":"<p>FalCAuN is a toolkit for testing black-box systems like CPSs (cyber-physical systems) based on automata learning and model checking. Given a list of specifications as STL(Signal Temporal Logic) formulas, FalCAuN tests whether the given system satisfies the specifications by finding an input signal that causes the corresponding output signal to violate the specifications. This process is called falsification.</p> <p>The main feature of FalCAuN is the combination of black-box checking and optimization-based falsification. BBC (black-box checking) [Meinke18], [Peled+99] is a testing method that constructs a Mealy machine via automata learning from a black-box system, then uses this machine for model checking the specifications. The main benefit of black-box checking is that the system model is unnecessary, and the system can be black-box. In contrast, the standard model checking requires the system model, which is usually challenging.</p> <p>Optimization-based falsification [Kapinski+16] is a testing method to find a counterexample violating a specification by minimizing the satisfaction degree of the specification. The minimization is done by black-box optimization, such as a genetic algorithm and simulated annealing. FalCAuN uses the robust semantics of STL as the degree.</p>"},{"location":"tutorial/tutorial/#tutorial-automatic-transmission-benchmark","title":"Tutorial: Automatic Transmission benchmark","text":"<p>Here, we demonstrate the usage of FalCauN with an example called automatic transmission benchmark [Hoxha+14] as a tutorial. We provide the same code in <code>example/kotlin/ATS1-step-5.ipynb</code>, which can be run using Jupyter with Kotlin kernel. Details are in <code>example/kotlin/README.md</code>. This example uses a Simulink model of an automatic transmission system. It is located in <code>example/kotlin/Autotrans_shift.mdl</code>. </p> <p>First, include FalCAuN and write <code>initScript</code> Matlab executes. <pre><code>import net.maswag.falcaun.*\n\n// Initializing script for MATLAB\nval initScript = \"\"\"\nversionString = version('-release');\noldpath = path;\npath(strcat(userpath, '/Examples/R', versionString, '/simulink_automotive/ModelingAnAutomaticTransmissionControllerExample/'), oldpath);\n\nmdl = 'Autotrans_shift';\nload_system(mdl);\n\"\"\"\nval paramNames = listOf(\"throttle\", \"brake\")\nval signalStep = 5.0\nval simulinkSimulationStep = 0.0025\n\n// Load the automatic transmission model. This must be manually closed!!\nval sul = SimulinkSUL(initScript, paramNames, signalStep, simulinkSimulationStep)\n</code></pre> <code>SimulinkSUL</code> implements the <code>Closable</code> interface of Java, and it is recommended to use the <code>use</code> function of Kotlin, though this example does not use it.</p> <p>Second, define a mapper. Since Mealy machines receive finite events, real-valued signals are abstracted into a finite alphabet. <code>NumericSULMapper</code> provides input, output, and (general) signal mappers:</p> <ul> <li>The input mapper maps discrete input events into a real-valued input signal.</li> <li>The output mapper maps a real-valued output signal into discrete observations.</li> <li>The signal mapper creates \"pseudo output signals\" from the input and output signals to handle complicated properties.</li> </ul> <p>The approximated Mealy machine uses these alphabet-abstracted signals. For instance, in the following example, an input signal consists of two dimensions (throttle and brake), and we create input events for each pair of the following values: (0.0, 0.0), (100.0, 0.0), (0.0, 325.0), and (100.0, 325.0). An output signal consists of three dimensions (velocity, acceleration, and gear value). By specifying <code>previous_max_output(0)</code> in the definition of signal mapper, it creates a pseudo signal of the maximum value of <code>output(0)</code> (velocity in this case) since the latest sampling point. The output mapper ignores the velocity, acceleration, and gear value and assigns a discrete observation for each of the following range of the pseudo signal: $(-\\infty, 20.0)$, $[20.0, 40.0)$, $[40.0, 60.0)$, $[60.0, 80.0)$, $[80.0, 100.0)$, $[100.0, 120.0)$, and $[120.0, \\infty)$.</p> <pre><code>// Define the input and output mappers\nval throttleValues = listOf(0.0, 100.0)\nval brakeValues = listOf(0.0, 325.0)\nval inputMapper = InputMapperReader.make(listOf(throttleValues, brakeValues))\nval ignoreValues = listOf(null)\nval velocityValues = listOf(20.0, 40.0, 60.0, 80.0, 100.0, 120.0, null)\nval accelerationValues = listOf(null)\nval gearValues = listOf(null)\nval outputMapperReader = OutputMapperReader(listOf(ignoreValues, accelerationValues, gearValues, velocityValues))\noutputMapperReader.parse()\nval mapperString = listOf(\"previous_max_output(0)\").joinToString(\"\\n\")\nval signalMapper: ExtendedSignalMapper = ExtendedSignalMapper.parse(BufferedReader(StringReader(mapperString)))\nassert(signalMapper.size() == 1)\nval mapper =\n    NumericSULMapper(inputMapper, outputMapperReader.largest, outputMapperReader.outputMapper, signalMapper)\n</code></pre> <p>Third, give STL formulas. The syntax of STL in FalCAuN is as follows.</p> <pre><code>expr : atomic\n     | expr &amp;&amp; expr\n     | expr || expr\n     | expr -&gt; expr\n     | ! expr\n     | GLOBALLY expr\n     | GLOBALLY _ INTERVAL expr\n     | EVENTUALLY expr\n     | EVENTUALLY _ INTERVAL expr\n     | X expr\n     | expr U expr\n     | expr U _ INTERVAL expr\n     | ( expr )\n\natomic : signal(NATURAL) == value\n       | signal(NATURAL) &lt; value\n       | signal(NATURAL) &gt; value\n       | signal(NATURAL) != value\n       | input(NATURAL) == value\n       | input(NATURAL) &lt; value\n       | input(NATURAL) &gt; value\n       | input(NATURAL) != value\n       | output(NATURAL) == value\n       | output(NATURAL) &lt; value\n       | output(NATURAL) &gt; value\n       | output(NATURAL) != value\n\nvalue : -? NATURAL | -? FLOAT\n\nGLOBALLY : '[]' | 'alw' | 'G'\n\nEVENTUALLY : '&lt;&gt;' | 'ev' | 'F'\n\nINTERVAL : [ NATURAL , NATURAL ]\n</code></pre> <p><code>GLOBALLY</code> and <code>EVENTUALLY</code> have three alternative notations with the same semantics. For STL semantics, see the paper [Waga20].</p> <p>In FalCAuN, STL formulas are given as strings. <pre><code>import net.maswag.falcaun.TemporalLogic.STLCost;\n\n// Define the STL properties\nval stlFactory = STLFactory()\nval stlList: List&lt;STLCost&gt; = listOf(\n    \"[] (signal(3) &lt; 120)\",\n).map { stlString -&gt;\n    stlFactory.parse(\n        stlString,\n        inputMapper,\n        outputMapperReader.outputMapper,\n        outputMapperReader.largest\n    )\n}.toList()\nval signalLength = 6\nval properties = AdaptiveSTLList(stlList, signalLength)\n</code></pre> <code>STLFactory</code> is used to parse them. <code>signal(3)</code> points to the fourth output signal, the pseudo signal in this case.</p> <p>Then, define a verifier using the above. A verifier needs <code>MealyEquivalenceOracle</code> to check if the given system and the learned Mealy machine behave equivalently. In this example, the verifier below has two equivalence oracles: <code>CornerCaseEQOracle</code> and <code>GAEQOracle</code>: <code>CornerCaseEQOracle</code> is an equivalence oracle that tests the equivalence for the corner case inputs, such as keeping the maximum throttle; <code>GAEQOracle</code> is an equivalence oracle based on a genetic algorithm. <code>addGAEQOracleAll</code> adds this oracle for each STL property. <pre><code>val verifier = NumericSULVerifier(sul, signalStep, properties, mapper)\n\n// Timeout must be set before adding equivalence testing methods\nverifier.setTimeout(5 * 60) // 5 minutes\n\n// First, try the corner cases\nverifier.addCornerCaseEQOracle(signalLength, signalLength / 2);\n\n// Constants for the GA-based equivalence testing\nval maxTest = 50000\nval populationSize = 200\nval crossoverProb = 0.5\nval mutationProb = 0.01\n\nverifier.addGAEQOracleAll(\n    signalLength,\n    maxTest,\n    ArgParser.GASelectionKind.Tournament,\n    populationSize,\n    crossoverProb,\n    mutationProb\n)\n\nval result = verifier.run()\n</code></pre></p> <p>You can show the result via <code>verifier</code>. <pre><code>// Print the result\nif (result) {\n    println(\"The property is likely satisfied\")\n} else {\n    for (i in 0 until verifier.cexProperty.size) {\n        println(\"${verifier.cexProperty[i]} is falsified by the following counterexample\")\n        println(\"cex concrete input: ${verifier.cexConcreteInput[i]}\")\n        println(\"cex abstract input: ${verifier.cexAbstractInput[i]}\")\n        println(\"cex output: ${verifier.cexOutput[i]}\")\n    }\n}\nprintln(\"Execution time for simulation: ${verifier.simulationTimeSecond} [sec]\")\nprintln(\"Number of simulations: ${verifier.simulinkCount}\")\nprintln(\"Number of simulations for equivalence testing: ${verifier.simulinkCountForEqTest}\")\n</code></pre></p> <p>In this example, since the system does not satisfy the specification, a counterexample violating the specification is shown as follows. <code>concrete input</code> is a list of real values specifying the signal given to the system. <code>abstract input</code> is the alphabet-abstracted input by the input mapper. <pre><code>[] ( output(3) &lt; 120.000000 ) is falsified by the following counterexample\ncex concrete input: [0.0 100.0 0.0; 5.0 100.0 0.0; 10.0 100.0 0.0; 15.0 100.0 0.0; 20.0 100.0 0.0]\ncex abstract input: ba ba ba ba ba\ncex abstract output: aaaa aaad aaae aaaf aaag\n</code></pre></p> <p>The following input and output to the target system shows this output above. </p> <p>Intuitively the formula <code>[] ( output(3) &lt; 120.000000 )</code> means that the velocity does not exceed <code>120</code>, and FalCAuN falsified this specification by finding a counterexample. This counterexample shows when <code>throttle</code> input keeps the max value <code>100</code>, full throttle, the velocity exceeds <code>120</code> in <code>20</code> ticks.</p> <p>The Mealy machine constructed by an automata learning algorithm is shown below. This graph highlighting the violating path is described by the above <code>abstract input</code> and <code>abstract output</code>. </p> <p>Finally, don't forget to terminate the Matlab engine. <pre><code>sul.close()\n</code></pre></p>"},{"location":"tutorial/tutorial/#references","title":"References","text":"<ul> <li>[Waga20]: Waga, Masaki. \"Falsification of cyber-physical systems with robustness-guided black-box checking.\" Proceedings of the 23rd International Conference on Hybrid Systems: Computation and Control. 2020.</li> <li>[Meinke18]: Meinke, Karl. \"Learning-based testing: recent progress and future prospects.\" Machine Learning for Dynamic Software Analysis: Potentials and Limits: International Dagstuhl Seminar 16172, Dagstuhl Castle, Germany, April 24-27, 2016, Revised Papers. Springer International Publishing, 2018.</li> <li>[Peled+99]: Peled, Doron, Moshe Y. Vardi, and Mihalis Yannakakis. \"Black box checking.\" International Conference on Protocol Specification, Testing and Verification. Boston, MA: Springer US, 1999.</li> <li>[Kapinski+16]: Kapinski, James, et al. \"Simulation-based approaches for verification of embedded control systems: An overview of traditional and advanced modeling, testing, and verification techniques.\" IEEE Control Systems Magazine 36.6 (2016): 45-64.</li> <li>[Hoxha+14]: Hoxha, Bardh, Houssam Abbas, and Georgios Fainekos. \"Benchmarks for Temporal Logic Requirements for Automotive Systems.\" ARCH@ CPSWeek 34 (2014): 25-30.</li> </ul>"}]}